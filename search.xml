<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 通过 JNA 调用 C/C++ 接口]]></title>
    <url>%2Fjna%2F</url>
    <content type="text"><![CDATA[缘起 项目中调用了第三方一个 Matlab 实现的数据清洗和机组状态评价的算法，但是对方不会除 Matlab 外的其他语言，最好就用 Matlab 生成了一个 dll/lib 文件。由于提供的接口质量真心不好，而且对方也无力修改，最终只好在其基础上用C++重新包装一下。在给我们的 Client 调用时，需要把从多数据源查询数据的细节封装掉，最终就形成了Java Client-&gt; Java Interface-&gt;C++ Interface-&gt;Matlab/C++ Interface 这样一个诡异的调用链。 只是 Java 单向调用 C++ 接口，故通过 JNA 实现。主要设计到 JNA 的结构体封装，指针声明及取值，结构体指针定义及取值。 实现 C++的封装接口逻辑非常简单，根据业务提供数据清洗和机组评价的两个接口。由于Matlab 导出的dll效率是真心差，不能每次加载，故提供 init/terminator 实现按需加载及停用。 C/C++ 头文件定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#ifndef __CALCULATOR_API_H__#define __CALCULATOR_API_H__#include &lt;cstdint&gt;#ifdef WIN32# define EXPORT_API __declspec(dllexport)#else# define EXPORT_API #endif// Random number to avoid errno conflicts#define CALCULATOR_ENOBASE 112345678/* Calculator exceptions */enum&#123; CALCULATOR_EXCEPTION_ILLEGAL_FUNCTION = 0x01, CALCULATOR_EXCEPTION_ILLEGAL_PARA&#125;;#define EMBXILFUN (CALCULATOR_ENOBASE + CALCULATOR_EXCEPTION_ILLEGAL_FUNCTION)#define EMBXILPARA (CALCULATOR_ENOBASE + CALCULATOR_EXCEPTION_ILLEGAL_PARA)typedef enum&#123; H2 = 0X01, CH4, C2H2, C2H4, TOTAL_HYDROCARBON,//总烃 CO, CO2&#125; OilChromatographyType;/** * 数据清洗结果 */typedef struct sImproveResult&#123; int32_t valid; // 有效数据个数 float validPercent; // 数据有效值占比 float* abnormalData; // 异常数据 int32_t abnormal_size; // 异常数据个数 float* optimizeData; // 优化后的数据 int32_t optimize_size; // 优化数据个数&#125; sImproveResult, *ImproveResult;/** * 变压器输入参数 */typedef struct sTransformer&#123; float h2Value; float totalHydrocarbon; // 总烃 float c2h2Value; float coValue; float co2Value; float dielectricLoss; // 介损 float dcResistance; //直阻 float absorptance; //吸收比 float polarizeFactor; // 极化系数 float electricCapacity; // 电容量 float moisture; // 微水 float breakdownVoltage; // 击穿电压 float oilDielectricLoss; // 油介损 float interfacialTension; //界面张力 float electricResistivity; //电阻率 int16_t runningLife; // 运行年限 float ambientTemperature; // 环境温度 float jointTemperature; //接头温度 float oilTankTemperature; // 油箱温度&#125; sTransformer, *Transformer;/** * 因素状态隶属度结果 */typedef struct sFusionResult&#123; float *h1; // 油色谱 int16_t h1_size; float *h2; // 电气试验 int16_t h2_size; float *h3; // 绝缘油 int16_t h3_size; float *h4; // 其余项 int16_t h4_size; float qz1; // 油色谱权重 float qz2; // 电气试验权重 float qz3; // 绝缘油权重 float qz4; // 其余项权重 float m; // 证据融合参数 float n; // 证据融合参数&#125; sFusionResult, *FusionResult;/** * 最终评价结果 */typedef struct sFactorResult&#123; float* state; int16_t state_size; int8_t* comment; int16_t comment_len;&#125; sFactorResult, *FactorResult;typedef struct&#123; int64_t time; float value;&#125; sImproveInput, *ImproveInput;typedef struct sReviewResult&#123; Transformer indexScore; int16_t indexScore_size; FusionResult indexFusion; FactorResult factorFusion;&#125; sReviewResult, *ReviewResult;#ifdef __cplusplusextern "C"&#123;#endif /** * 数据清洗 * @param original[in] 原始数据起始地址 * @param originalLen[in] 原始数据长度 * @param result [out] 数据清洗结果 * @return 0:成功;非0：失败 */ EXPORT_API int16_t improve_data(const ImproveInput original, const int32_t originalLen, ImproveResult result); /** * 状态评价计算 * @param transformer[in] 主变参数 * @param result[out] 评价结果 * @return 0:成功;非0：失败 */ EXPORT_API int16_t review_transformer(const Transformer transformer, ReviewResult result); /** * 初始化 dll * @return [description] */ EXPORT_API int16_t init(); /** * 根据 err num 获取异常信息描述 * @param errnum[in] errnum * @return errnum 对应的异常信息描述 */ EXPORT_API const int8_t* calculator_strerror(int errnum); /** * 停止计算模块 **/ EXPORT_API void terminator();#ifdef __cplusplus&#125;#endif#endif /*__CALCULATOR_API_H__*/ Java 接口定义 CalculatorApi CalculatorApi 提供与 C++ 头文件中声明一致的函数定义，继承 Library 123456789101112import com.sun.jna.Library;public interface CalculatorApi extends Library &#123; int improve_data(ImproveInputWrapper.ByReference original, int originalLen, ImproveResultWrapper result); int init(); int review_transformer(TransformerWrapper transformer, ReviewResult result); void terminator();&#125; FactorResultWrapper 作为 C++ 中 结构体 FactorResult的封装类，需要继承Structure，原始 state定义为 float *，通过 Pointer 与其对应。必须要实现 getFieldOrder,其中字段的顺序必须和 C++ 中保持一致，且所有相关字段必须要设成 Public 。使用的时候，用的引用传递，所以必须要实现Structure.ByReference接口。具体代码实现如下： 123456789101112131415161718192021222324252627import com.sun.jna.Pointer;import com.sun.jna.Structure;import java.util.List;public class FactorResultWrapper extends Structure &#123; private static final List&lt;String&gt; FIELDS_ORDER = createFieldsOrder("state", "state_size", "comment", "comment_len"); public Pointer state; public int state_size; public String comment; public int comment_len; public static class ByReference extends FactorResultWrapper implements Structure.ByReference &#123; &#125; public static class ByValue extends FactorResultWrapper implements Structure.ByValue &#123; &#125; public FactorResultWrapper() &#123; super(); &#125; @Override protected List&lt;String&gt; getFieldOrder() &#123; return FIELDS_ORDER; &#125;&#125; FusionResultWrapper 作为 C++ 中 结构体 FusionResult的封装类，定义同上。 1234567891011121314151617181920212223242526272829303132333435import com.sun.jna.Pointer;import com.sun.jna.Structure;import java.util.List;public class FusionResultWrapper extends Structure &#123; private static final List&lt;String&gt; FIELDS_ORDER = createFieldsOrder("h1", "h1_size", "h2", "h2_size", "h3", "h3_size", "h4", "h4_size", "qz1", "qz2", "qz3", "qz4", "m", "n"); public Pointer h1; // 油色谱 public int h1_size; public Pointer h2; // 电气试验 public int h2_size; public Pointer h3; // 绝缘油 public int h3_size; public Pointer h4; // 其余项 public int h4_size; public float qz1; // 油色谱权重 public float qz2; // 电气试验权重 public float qz3; // 绝缘油权重 public float qz4; // 其余项权重 public float m; // 证据融合参数 public float n; // 证据融合参数 public static class ByReference extends FusionResultWrapper implements Structure.ByReference &#123; &#125; public static class ByValue extends FusionResultWrapper implements Structure.ByValue &#123; &#125; @Override protected List&lt;String&gt; getFieldOrder() &#123; return FIELDS_ORDER; &#125;&#125; ImproveInputWrapper 作为 C++ 中 结构体 ImproveInput的封装类，就是基本类型映射。 1234567891011121314151617181920import com.sun.jna.Structure;import java.util.List;public class ImproveInputWrapper extends Structure &#123; private static final List&lt;String&gt; FIELDS_ORDER = createFieldsOrder("time", "value"); public long time; public float value; public ImproveInputWrapper() &#123; &#125; public static class ByReference extends ImproveInputWrapper implements Structure.ByReference &#123; &#125; @Override protected List&lt;String&gt; getFieldOrder() &#123; return FIELDS_ORDER; &#125;&#125; ImproveResultWrapper 作为 C++ 中 结构体ImproveResult的封装类 1234567891011121314151617181920212223import com.sun.jna.Pointer;import com.sun.jna.Structure;import java.util.List;public class ImproveResultWrapper extends Structure &#123; private static final List&lt;String&gt; FIELDS_ORDER = createFieldsOrder("valid", "validPercent", "abnormalData", "abnormal_size", "optimizeData", "optimize_size"); public int valid; // 有效数据个数 public float validPercent; // 数据有效值占比 public Pointer abnormalData; // 异常数据 public int abnormal_size; // 异常数据个数 public Pointer optimizeData; // 优化后的数据 public int optimize_size; public static class ByReference extends ImproveResultWrapper implements Structure.ByReference &#123; &#125; @Override protected List&lt;String&gt; getFieldOrder() &#123; return FIELDS_ORDER; &#125;&#125; ReviewResult 作为 C++ 中 结构体ReviewResult的封装类，此处包含多个结构体指针，需要通过 ByReference来声明，且需要分配内存。比如 TransformerWrapper.ByReference indexScore，需要通过 toArray分配内存 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import com.sun.jna.Memory;import com.sun.jna.Native;import com.sun.jna.Structure;import java.util.List;public class ReviewResult extends Structure &#123; private final int STATE_SIZE = 5; private static final List&lt;String&gt; FIELDS_ORDER = createFieldsOrder("indexScore", "indexScore_size", "indexFusion", "factorFusion"); public TransformerWrapper.ByReference indexScore; public int indexScore_size; public FusionResultWrapper.ByReference indexFusion; public FactorResultWrapper.ByReference factorFusion; public ReviewResult() &#123; super(); if (indexScore_size == 0) indexScore_size = STATE_SIZE; indexScore = new TransformerWrapper.ByReference(); TransformerWrapper[] wrappers = (TransformerWrapper[]) indexScore.toArray(indexScore_size); for (TransformerWrapper wrapper : wrappers) &#123; wrapper.h2Value = 0f; wrapper.totalHydrocarbon = 0f; // 总烃 wrapper.c2h2Value = 0f; wrapper.coValue = 0f; wrapper.co2Value = 0f; wrapper.dielectricLoss = 0f; // 介损 wrapper.dcResistance = 0f; //直阻 wrapper.absorptance = 0f; //吸收比 wrapper.polarizeFactor = 0f; // 极化系数 wrapper.electricCapacity = 0f; // 电容量 wrapper.moisture = 0f; // 微水 wrapper.breakdownVoltage = 0f; // 击穿电压 wrapper.oilDielectricLoss = 0f; // 油介损 wrapper.interfacialTension = 0f; //界面张力 wrapper.electricResistivity = 0f; //电阻率 wrapper.runningLife = 0; // 运行年限 wrapper.ambientTemperature = 0f; // 环境温度 wrapper.jointTemperature = 0f; //接头温度 wrapper.oilTankTemperature = 0f; // 油箱温度 &#125; indexFusion = new FusionResultWrapper.ByReference(); indexFusion.h1 = new Memory(STATE_SIZE * Native.getNativeSize(Float.TYPE)); indexFusion.h1_size = STATE_SIZE; indexFusion.h2 = new Memory(STATE_SIZE * Native.getNativeSize(Float.TYPE)); indexFusion.h2_size = STATE_SIZE; indexFusion.h3 = new Memory(STATE_SIZE * Native.getNativeSize(Float.TYPE)); indexFusion.h3_size = STATE_SIZE; indexFusion.h4 = new Memory(STATE_SIZE * Native.getNativeSize(Float.TYPE)); indexFusion.h4_size = STATE_SIZE; factorFusion = new FactorResultWrapper.ByReference(); factorFusion.state = new Memory(STATE_SIZE * Native.getNativeSize(Float.TYPE)); factorFusion.state_size = STATE_SIZE; factorFusion.comment = ""; factorFusion.comment_len = 0; &#125; public static class ByReference extends ReviewResult implements Structure.ByReference &#123; &#125; @Override protected List&lt;String&gt; getFieldOrder() &#123; return FIELDS_ORDER; &#125;&#125; TransformerWrapper 作为 C++ 中 结构体Transformer的封装类 1234567891011121314151617181920212223242526272829303132333435363738394041424344import com.sun.jna.Structure;import java.util.List;public class TransformerWrapper extends Structure &#123; private static final List&lt;String&gt; FIELDS_ORDER = createFieldsOrder("h2Value", "totalHydrocarbon", "c2h2Value", "coValue", "co2Value", "dielectricLoss", "dcResistance", "absorptance", "polarizeFactor", "electricCapacity", "moisture", "breakdownVoltage", "oilDielectricLoss", "interfacialTension", "electricResistivity", "runningLife", "ambientTemperature", "jointTemperature", "oilTankTemperature"); public float h2Value; public float totalHydrocarbon; // 总烃 public float c2h2Value; public float coValue; public float co2Value; public float dielectricLoss; // 介损 public float dcResistance; //直阻 public float absorptance; //吸收比 public float polarizeFactor; // 极化系数 public float electricCapacity; // 电容量 public float moisture; // 微水 public float breakdownVoltage; // 击穿电压 public float oilDielectricLoss; // 油介损 public float interfacialTension; //界面张力 public float electricResistivity; //电阻率 public short runningLife; // 运行年限 public float ambientTemperature; // 环境温度 public float jointTemperature; //接头温度 public float oilTankTemperature; // 油箱温度 public static class ByReference extends TransformerWrapper implements Structure.ByReference &#123; &#125; public static class ByValue extends TransformerWrapper implements Structure.ByValue &#123; &#125; public TransformerWrapper() &#123; super(); &#125; @Override protected List&lt;String&gt; getFieldOrder() &#123; return FIELDS_ORDER; &#125;&#125; CalculatorImpl Java 接口的实现类，首先需要从 Jar 中解压 dll 到指定目录，然后通过此目录加载 dll。依赖关系为 Java 接口通过 JNA 加载calculator.dll ，而calculator.dll依赖 pingjia.dll和另外一个dll。 三个dll必须在同一目录下， JNA 只需要加载 calculator.dll。因为此处只是在 WIN32 平台执行，所以加载时，通过 Native.loadLibrary 加载的时候，在文件名前加了 /，否则 JNA 会在文件前增加平台相关的perfix导致加载失败。 123456789101112131415161718192021222324public class CalculatorImpl implements Calculator &#123; private static final Log LOGGER = Logs.getLog(CalculatorImpl.class); private static CalculatorApi CALCULATOR_API; static &#123; try &#123; String current = System.getProperty("user.dir"); File matlab = new File(current, "matlab"); System.setProperty("java.library.path", matlab.getPath()); System.setProperty("jna.library.path", matlab.getPath()); // 从 Jar 包 resources 中解压 dll 到指定目录 // Files.createDirIfNoExists(matlab); // Files.clearDir(matlab); // 加载 dll 并映射成 Java 接口 CALCULATOR_API = Native.loadLibrary("/calculator.dll", CalculatorApi.class); // 初始化dll (C++ 实现) int ret = CALCULATOR_API.init(); LOGGER.debugf("init calculator (%d)", ret); &#125; catch (Exception e) &#123; LOGGER.error(e.getMessage(), e); &#125; &#125;&#125; 使用 improveData 数据清洗，需要根据Java Wrapper的接口，组织数据，内存都在 Java 端分配，由 Java 端负责回收。Pointer的内存分配，通过 new Memory(size)来分配。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private TwoTuple&lt;String, CalculationResult&gt; improveData(String label, List&lt;TwoTuple&lt;String, Float&gt;&gt; values) throws CalculatorException &#123; ImproveInputWrapper.ByReference inputsRef = new ImproveInputWrapper.ByReference(); final int valueSize = values.size(); ImproveInputWrapper[] inputs = (ImproveInputWrapper[]) inputsRef.toArray(valueSize); LOGGER.debug(label + " inputs: "); for (int i = 0; i &lt; valueSize; i++) &#123; try &#123; TwoTuple&lt;String, Float&gt; entry = values.get(i); Date date = FORMATTER.parse(entry.getKey()); inputs[i].time = date.getTime(); inputs[i].value = entry.getValue(); LOGGER.debugf("%d: %s(%d) -&gt; %f", i, entry.getKey(), inputs[i].time, inputs[i].value); &#125; catch (ParseException e) &#123; LOGGER.error(e.getMessage(), e); &#125; &#125; ImproveResultWrapper.ByReference impResultRef = new ImproveResultWrapper.ByReference(); impResultRef.abnormalData = new Memory(valueSize * Native.getNativeSize(Float.TYPE)); impResultRef.abnormalData.setFloat(0, 0); impResultRef.optimizeData = new Memory(valueSize * Native.getNativeSize(Float.TYPE)); impResultRef.optimizeData.setFloat(0, 0); impResultRef.abnormal_size = 0; impResultRef.validPercent = 0; impResultRef.optimize_size = 0; int flag = CALCULATOR_API.improve_data(inputsRef, inputs.length, impResultRef); LOGGER.debug("improve_data flag: " + flag); CalculationResult.CalculationResultBuilder builder = CalculationResult.CalculationResultBuilder .aCalculationResult().withOriginalData(values); if (flag == 0) &#123; builder.withValidPercent(impResultRef.validPercent).withValidSize(impResultRef.valid); int abnormalSize = impResultRef.abnormal_size; LOGGER.debug("abnormalSize: " + abnormalSize); if (abnormalSize &gt; 0) &#123; float[] abnormalValues = impResultRef.abnormalData.getFloatArray(0, abnormalSize); builder.withAbnormalData(Collections.unmodifiableList(Lang.array2list(abnormalValues, Float.class))); &#125; else &#123; builder.withAbnormalData(Collections.&lt;Float&gt;emptyList()); &#125; int optimizeSize = impResultRef.optimize_size; LOGGER.debug("optimizeSize: " + optimizeSize); if (optimizeSize &gt; 0) &#123; float[] optimizeValues = impResultRef.optimizeData.getFloatArray(0, optimizeSize); builder.withOptimizeData(Collections.unmodifiableList(Lang.array2list(optimizeValues, Float.class))); &#125; else &#123; builder.withOptimizeData(Collections.&lt;Float&gt;emptyList()); &#125; &#125; CalculationResult result = builder.build(); LOGGER.debug(result); return new TwoTuple&lt;&gt;(label, result); &#125; reviewTransformer 机组状态评价，获取 float *的数据时候的，需要通过 getFloatArray 获取数据。 12345678910111213141516171819202122232425262728293031323334private TransformerResult reviewTransformer(Map&lt;String, Float&gt; values) throws CalculatorException &#123; TransformerWrapper.ByReference transformerRef = new TransformerWrapper.ByReference(); setTransformer(transformerRef, values); ReviewResult.ByReference reviewResultRef = new ReviewResult.ByReference(); int flag = CALCULATOR_API.review_transformer(transformerRef, reviewResultRef); LOGGER.debugf("review_transformer flag: %d", flag); TransformerResult result = new TransformerResult(); if (flag == 0) &#123; float[] states = reviewResultRef.factorFusion.state.getFloatArray(0, reviewResultRef.factorFusion.state_size); result.setState(states).setComment(reviewResultRef.factorFusion.comment); float[] h1 = reviewResultRef.indexFusion.h1.getFloatArray(0, reviewResultRef.indexFusion.h1_size); result.setH1(h1); float[] h2 = reviewResultRef.indexFusion.h2.getFloatArray(0, reviewResultRef.indexFusion.h2_size); result.setH2(h2); float[] h3 = reviewResultRef.indexFusion.h3.getFloatArray(0, reviewResultRef.indexFusion.h3_size); result.setH3(h3); float[] h4 = reviewResultRef.indexFusion.h4.getFloatArray(0, reviewResultRef.indexFusion.h4_size); result.setH4(h4); result.setQz1(reviewResultRef.indexFusion.qz1).setQz2(reviewResultRef.indexFusion.qz2) .setQz3(reviewResultRef.indexFusion.qz3).setQz4(reviewResultRef.indexFusion.qz4) .setM(reviewResultRef.indexFusion.m).setN(reviewResultRef.indexFusion.n); TransformerWrapper[] wrappers = (TransformerWrapper[]) reviewResultRef.indexScore.toArray(reviewResultRef.indexScore_size); Transformer[] transformers = transformerWrapperToTransformer(wrappers); result.setTransformers(transformers); LOGGER.debug("transfer review result."); &#125; return result; &#125; 小结 优点 Java 端不需要编写C/C++代码 缺点 需要编写与 C/C++ 对应的结构体映射，碰到复杂的结构体工作量不小 结构体指针/数据通过 toArray获取数据时，效率较低，尤其时数据量比较大的时候 如果时C/C++端分配的内存，Java 端管理不了，如果C/C++不提供显式回收接口，会导致内存泄露 代码不规范，破坏了OO封装性，比如 field 必须要 Public 需要实现 Structure.ByReference接口，这些明显都可以通过注解来解决 ---EOF---]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JNA</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GPG 导入导出 Key]]></title>
    <url>%2FHowto-import-export-gpg-key%2F</url>
    <content type="text"><![CDATA[在多台电脑上操作的时候经常会涉及到 GPG 公钥/私钥的导入导出，比方说 GitHub 支持 GPG 加密 Commit，在多台电脑上使用相同的 Key 可以省去很多配置工作。 列出本地的所有 Key 执行 gpg --list-keys 列出本地所有的密钥 输出结果类似 12345 $ gpg --list-keys /home/$USER/.gnupg/pubring.gpg ----------------------------------- pub 4 096R/375A500B 2017-03-22 [有效至：2018-03-22] uid Goren G (Git) &lt;gythialy.koo+git@gmail.com&gt; sub 4096R/ADB9D36C 2017-03-22 [有效至：2018-03-22] 导出 根据 375A500B 导出相应的公钥和私钥 12gpg --output mygpgkey_pub.gpg --armor --export 375A500Bgpg --output mygpgkey_sec.gpg --armor --export-secret-key 375A500B 导入 导入刚导入的文件 123gpg --import ~/mygpgkey_pub.gpggpg --allow-secret-key-import --import ~/mygpgkey_sec.gpg` ---EOF---]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>gpg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babun 配置]]></title>
    <url>%2Fbabun-config%2F</url>
    <content type="text"><![CDATA[介绍 babun 号称是开箱即用的，本质是上就是 cygwin 加上了一些预设的配置。特性如下: Pre-configured Cygwin with a lot of addons Silent command-line installer, no admin rights required pact - advanced package manager (like apt-get or yum) xTerm-256 compatible console HTTP(s) proxying support Plugin-oriented architecture Pre-configured git and shell Integrated oh-my-zsh Auto update feature &quot;Open Babun Here&quot; context menu entry 安装 下载安装包解压缩到任意目录后，运行 install.bat。也可以使用 /t %target_folder% 指定安装目录。 配置 既然是开箱即用，对大多数人来说当然不需要太多配置，一般需要以下两个命令： babun check 用于判断环境是否正确 babun update 用于判断是否有新的更新包 包管理 babun 自带了叫做 pact 的包管理，修改自 apt-cyg, 但比较弱，用法如下： 123456789101112131415161718&#123; ~ &#125; » pact --helppact: Installs and removes Cygwin packages.Usage: "pact install &lt;package names&gt;" to install given packages "pact remove &lt;package names&gt;" to remove given packages "pact update &lt;package names&gt;" to update given packages "pact show" to show installed packages "pact find &lt;patterns&gt;" to find packages matching patterns "pact describe &lt;patterns&gt;" to describe packages matching patterns "pact packageof &lt;commands or files&gt;" to locate parent packages "pact invalidate" to invalidate pact caches (setup.ini, etc.)Options: --mirror, -m &lt;url&gt; : set mirror --invalidate, -i : invalidates pact caches (setup.ini, etc.) --force, -f : force the execution --help --version 和 Windows 共享配置 添加环境变量 HOME，值为 Windows 的用户目录 C:\Users\%USERNAME% 启动 babun，执行 babun install，重启 babun %USERNAME% 不能包含空格。如果用户名已经有空格，参考这里解决。 代理设置 只需要取消 .babunrc 中的注释 (%USERPROFILE%\.babunrc) 12345# Uncomment this lines to set up your proxyexport http_proxy=user:password@server:portexport https_proxy=$http_proxyexport ftp_proxy=$http_proxyexport no_proxy=localhost 镜像 修改 ~/.pact/pact.repo 中的 PACT_REPO 字段 12345678910111213141516#PACT_REPO=http://mirrors.kernel.org/sourceware/cygwin/PACT_REPO=http://mirrors.neusoft.edu.cn/cygwin/# POPULAR HTTP REPOSITORIES# http://mirror.switch.ch/ftp/mirror/cygwin/# POPULAR FTP REPOSITORIES# ftp://mirror.switch.ch/mirror/cygwin/# ftp://ftp.inf.tu-dresden.de/software/windows/cygwin32/# ftp://mirrors.kernel.org/sourceware/cygwin/# ftp://gd.tuwien.ac.at/gnu/cygwin/# ftp://ftp.iij.ad.jp/pub/cygwin/# ftp://mirror.cpsc.ucalgary.ca/cygwin.com/# FULL LIST# http://cygwin.com/mirrors.html 常用开发环境配置 Python babun 自带的 Python2 并没有安装 pip，需要手动安装 123pact install python-setuptools python-mingpact install libxml2-devel libxslt-devel libyaml-develcurl -skS https://bootstrap.pypa.io/get-pip.py | python Ruby 执行 pact install ruby 如果 ruby -v 不能返回版本，执行 update.bat 更新 cygwin 的版本。via Issue #483 FAQ compdef: unknown command or service: git 12$ compinit$ cp .zcompdump .zcompdump-$HOSTNAME-$ZSH_VERSION 删除右键中的 Open Babun here 执行 babun shell-here remove 与 ConEmu 集成 %userprofile%\.babun\cygwin\bin\mintty.exe /bin/env CHERE_INVOKING=1 /bin/zsh.exe X64 官方对于 64 位的解释。懒人也可以直接使用这个 PR 编译的分发包。有兴趣的也可以通过我合并的 x64 分支 自行构建。 总结 总的来说，babun 比 MSYS2 慢，包也不多，稳定性/兼容性貌似好一点。 最终配置效果： ---EOF---]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>babun</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetty 配置 Log4J]]></title>
    <url>%2Fjetty-log4j-conf%2F</url>
    <content type="text"><![CDATA[缘起 我们一台很老的装置中用了 Jetty v7.1.6，由于种种原因，不能升级新版本。某次由于一个 bug 导致一直写日志，最后把硬盘给写爆了，所以用 Log4J 记录日志，方便控制日志大小等。 注：在 Jetty 最新的版本中，配置 Log4J 并不需要如此。 配置 下载 Log4J log4j-1.2.17.jar slf4j-api-1.7.9.jar slf4j-log4j12-1.7.9.jar 复制 jar 包到 Jetty 目录中 lib/ext 文件夹中 1234-rwxr-xr-x 1 root root 0 Jul 16 2010 .donotdelete-rw-r--r-- 1 root root 489884 Nov 19 13:06 log4j-1.2.17.jar-rw-r--r-- 1 root root 32121 Nov 19 13:09 slf4j-api-1.7.9.jar-rw-r--r-- 1 root root 8867 Nov 19 16:55 slf4j-log4j12-1.7.9.jar 在 Jetty 目录中 resources 文件夹中新建 log4j.properties 1234567891011121314# Basic Log4j Configuration with STDOUT and File logginglog4j.rootLogger=DEBUG, filerlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%nlog4j.appender.filer=org.apache.log4j.RollingFileAppenderlog4j.appender.filer.layout=org.apache.log4j.PatternLayoutlog4j.appender.filer.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%nlog4j.appender.filer.File=$&#123;jetty.home&#125;/logs/jetty.loglog4j.appender.filer.MaxFileSize=1MBlog4j.appender.filer.MaxBackupIndex=20 为了测试日志，配置设置的日志打印级别为DEBUG，单个文件大小为 1M，实际使用中根据具体使用场景调整。 修改 start.ini，OPTIONS 中 ext 必须放在 resources 前面 12345678#===========================================================# Start classpath OPTIONS.# These control what classes are on the classpath# for a full listing do# java -jar start.jar --list-options#-----------------------------------------------------------OPTIONS=Server,jsp,jmx,websocket,ext,resources#----------------------------------------------------------- 注：如需手动设置 JVM 内存配置，需要添加 --exec。这样就会有一个 java 进程常在。 创建启动脚本，原理很简单，就是设置 JAVA_HOME 和 JETTY_HOME 两个环境变量，然后调用 Jetty 自身的脚本。如果已经设置全局的环境变量，此步可省略 1234567891011121314151617181920212223#!/bin/shexport JAVA_HOME=/usr/java/jdkexport JETTY_HOME=/home/data/jettycd $JETTY_HOME/binpwdcase "$1" in start) ./jetty.sh start ;; stop) ./jetty.sh stop ;; restart) ./jetty.sh restart ;; *) echo "Usage: $0 $1 &#123;start|stop|restart&#125;" ;;esacexit 0 脚本中 JAVA_HOME 和 JETTY_HOME 是必须的。 效果 12345678910111213141516171819202122-rw-r--r-- 1 root root 27995 Nov 30 14:51 2015_11_27.stderrout.log-rw-r--r-- 1 root root 8060 Nov 30 14:51 EA0104-0.log-rw-r--r-- 1 root root 968686 Nov 30 14:52 jetty.log-rw-r--r-- 1 root root 1050948 Nov 27 15:57 jetty.log.1-rw-r--r-- 1 root root 1048812 Nov 27 15:52 jetty.log.10-rw-r--r-- 1 root root 1050923 Nov 27 15:52 jetty.log.11-rw-r--r-- 1 root root 1051665 Nov 27 15:49 jetty.log.12-rw-r--r-- 1 root root 1050713 Nov 27 15:47 jetty.log.13-rw-r--r-- 1 root root 1051495 Nov 27 15:47 jetty.log.14-rw-r--r-- 1 root root 1052634 Nov 27 15:47 jetty.log.15-rw-r--r-- 1 root root 1052521 Nov 27 15:29 jetty.log.16-rw-r--r-- 1 root root 1049512 Nov 27 15:29 jetty.log.17-rw-r--r-- 1 root root 1051501 Nov 27 15:29 jetty.log.18-rw-r--r-- 1 root root 1049831 Nov 27 15:56 jetty.log.2-rw-r--r-- 1 root root 1051016 Nov 27 15:56 jetty.log.3-rw-r--r-- 1 root root 1049532 Nov 27 15:56 jetty.log.4-rw-r--r-- 1 root root 1052064 Nov 27 15:56 jetty.log.5-rw-r--r-- 1 root root 1049274 Nov 27 15:56 jetty.log.6-rw-r--r-- 1 root root 1050903 Nov 27 15:56 jetty.log.7-rw-r--r-- 1 root root 1051740 Nov 27 15:52 jetty.log.8-rw-r--r-- 1 root root 1052915 Nov 27 15:52 jetty.log.9-rw-r--r-- 1 root root 55 Nov 27 15:52 start.log start.log 是 start.jar 创建的，会根据 etc/jetty-logging.xml 中配置决定是否从定向内容。 ---EOF---]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Jetty</tag>
        <tag>Log4J</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动下载 XCode 文档和模拟器]]></title>
    <url>%2Fdownload-xcode-documentation-sets-manually%2F</url>
    <content type="text"><![CDATA[缘起 由于众所周知的原因，也就是 Apple 的云真的很烂，App Store 还能通过 DNS 等手段加速更新。对于 XCode 简直就是噩梦，挂不挂都是一个样子，非常慢。不幸中之大幸，虽然 XCode 本身下载很慢，但是可以手动下载好之后，通过 XCode 安装。 文档 手动下载文档可以通过以下几步解决，via stackoverflow。 通过这个地址找到需要下载的文件的路径 12345678910111213141516171819202122232425262728293031323334&lt;!-- START OS X doc set --&gt;&lt;dict&gt; &lt;key&gt;fileSize&lt;/key&gt; &lt;integer&gt;931959772&lt;/integer&gt; &lt;key&gt;identifier&lt;/key&gt; &lt;string&gt;com.apple.adc.documentation.OSX&lt;/string&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;OS X 10.11.4 Documentation&lt;/string&gt; &lt;key&gt;source&lt;/key&gt; &lt;string&gt;https://devimages.apple.com.edgekey.net/docsets/20160321/031-52211-A.dmg&lt;/string&gt; &lt;key&gt;userInfo&lt;/key&gt; &lt;dict&gt; &lt;key&gt;ActivationPredicate&lt;/key&gt; &lt;string&gt;$XCODE_VERSION &amp;gt;= '7.3'&lt;/string&gt; &lt;key&gt;Category&lt;/key&gt; &lt;string&gt;Documentation&lt;/string&gt; &lt;key&gt;IconType&lt;/key&gt; &lt;string&gt;IDEDownloadablesTypeDocSet&lt;/string&gt; &lt;key&gt;InstallPrefix&lt;/key&gt; &lt;string&gt;$(HOME)/Library/Developer/Shared/Documentation/DocSets&lt;/string&gt; &lt;key&gt;InstalledIfAllReceiptsArePresentOrNewer&lt;/key&gt; &lt;dict&gt; &lt;key&gt;com.apple.pkg.10.9.OSXDocset&lt;/key&gt; &lt;string&gt;10.9.0.0.1.1458364023&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;RequiresADCAuthentication&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Summary&lt;/key&gt; &lt;string&gt;My description of content&lt;/string&gt; &lt;/dict&gt; &lt;key&gt;version&lt;/key&gt; &lt;string&gt;1014.5&lt;/string&gt;&lt;/dict&gt;&lt;!-- END OS X doc set --&gt; 下载 source 节点对应的内容，在这个示例中也就是这个，可以通过第三方的下载工具，比如 asia2 下载。 按照 identifier string + - + version string + .dmg 的格式重命名文件，在这个示例中也就是 com.apple.adc.documentation.OSX-1014.5.dmg 把重命名后的文件放到 ~/Library/Caches/com.apple.dt.Xcode/Downloads/ 中，如果没有 Downloads 文件夹就创建一个， 如果 Downloads 中有后缀为 dvtdownloadableindex 的文件，全部删除 删除 ~/Library/Developer/Shared/Documentation/DocSets 中对应的 docset 在 XCode 中 Preferences/Download 中下载对应的文档，XCode 会校验刚才复制过去的文件进行安装 模拟器 打开 XCode，Preferences/Download 中下载模拟器 打开 Console.app，清空日志 在 XCode 中取消下载 在 Console.app 中会看到取消的日志，其他包含完整的下载地址 通过 asia2 等第三方工具下载刚才地址中的文件 把下载好的文件复制到 ~/Library/Caches/com.apple.dt.Xcode/Downloads 中，如果没有 Downloads 文件夹就创建一个， 如果 Downloads 中有后缀为 dvtdownloadableindex 的文件，全部删除 在 XCode 中安装刚才下载的模拟器 如果需要删除不需要的模拟器，可以在 /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 中直接删除 ---EOF---]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>OS X</tag>
        <tag>XCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MSYS2 配置]]></title>
    <url>%2Fmsys2-config%2F</url>
    <content type="text"><![CDATA[介绍 MSYS2 是 MSYS 的一个升级版, 准确的说是集成了 pacman 和 Mingw-w64的 Cygwin 升级版。与 MSYS 最大的区别是移植了 Pacman。 比较 特点 Cygwin MinGW/MSYS MSYS2 是否GNU 否 是 是 软件支持？ 支持绝大多数的 GNU 软件 支持常用软件 支持大多数 GNU 软件 更类似 Linux？ 在 Windows 中模拟 Linux 实现了 Bash 等主要的 Linux 程序 原生 64/32bit 支持 GCC 编译 独立的 Windows/Linux 程序编译(MingGW32 交叉编译/依赖 cygwin1.dll) 独立的 Windows 程序编译 独立的 Windows 程序编译 中文支持 直接支持中文显示和输入法 需要配置才能支持中文显示和输入，删除一个中文字符需要删除 2 次 支持中文显示和输入法，中文帮助系统和中文提示（部分软件） 运行速度 慢 快 快 安装 安装 MSYS2 从官网下载 MSYS2 安装文件, 一路 Next 即可。 安装开发环境 pacman -S --needed base-devel msys2-devel mingw-w64-x86_64-toolchain 配置 环境变量 123MSYS_HOME=D:\msys64MINGW_HOME=D:\msys64\mingw64LIBRARY_PATH=D:\msys64\mingw64\lib 镜像配置 如果网络环境不好的话，可以增加国内的镜像，速度改进非常明显。 修改 /etc/pacman.d/ 文件夹中修改 mirrorlist 开头的三个文件： mirrorlist.mingw32 12345678910#### 32-bit Mingw-w64 repository mirrorlist##Server=http://mirrors3.ustc.edu.cn/msys2/REPOS/MINGW/i686## Primary## msys2.orgServer = http://repo.msys2.org/mingw/i686Server = http://downloads.sourceforge.net/project/msys2/REPOS/MINGW/i686Server = http://www2.futureware.at/~nickoe/msys2-mirror/i686/ mirrorlist.mingw64 12345678910#### 64-bit Mingw-w64 repository mirrorlist##Server=http://mirrors3.ustc.edu.cn/msys2/REPOS/MINGW/x86_64## Primary## msys2.orgServer = http://repo.msys2.org/mingw/x86_64Server = http://downloads.sourceforge.net/project/msys2/REPOS/MINGW/x86_64Server = http://www2.futureware.at/~nickoe/msys2-mirror/x86_64/ mirrorlist.msys 1234567891011#### MSYS2 repository mirrorlist##Server=http://mirrors3.ustc.edu.cn/msys2/REPOS/MSYS2/$arch## Primary## msys2.orgServer = http://repo.msys2.org/msys/$archServer = http://downloads.sourceforge.net/project/msys2/REPOS/MSYS2/$archServer = http://www2.futureware.at/~nickoe/msys2-mirror/msys/$arch/ 代理 如果需要通过代理才能上网的话，可以在 /etc/profile.d/ 增加 proxy.sh，内容如下: 123456export http_proxy=%PROXY_SERVER%:%PROXY_PORT%export https_proxy=%PROXY_SERVER%:%PROXY_PORT%export ftp_proxy=%PROXY_SERVER%:%PROXY_PORT%export HTTP_PROXY=%PROXY_SERVER%:%PROXY_PORT%export HTTPS_PROXY=%PROXY_SERVER%:%PROXY_PORT%export FTP_PROXY=%PROXY_SERVER%:%PROXY_PORT% 用户目录 修改 /etc/fstab，映射用户目录，与宿主共享配置，这样类似 gitconfig 这样的配置只需要配置一份。 123456# For a description of the file format, see the Users Guide# http://cygwin.com/cygwin-ug-net/using.html#mount-table# DO NOT REMOVE NEXT LINE. It remove cygdrive prefix from pathnone / cygdrive binary,posix=0,noacl,user 0 0C:/Users /home ntfs binary,noacl,auto 1 1 公用 HOME 目录 环境变量中添加 MSYS2_PATH_TYPE 值为 inherit 包管理 刷新软件包 pacman -Sy 安装新包 pacman -S &lt;package_names|package_groups&gt; 删除 pacman -R &lt;package_names|package_groups&gt; 搜索 pacman -Ss &lt;name_pattern&gt; 更多请参考 Arch Linux wiki. 安装zsh和oh my zsh 安装zsh 12pacman -Syupacman -S zsh 安装 oh my zsh 1sh -c "$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" zsh 的配置文件是 ~/.zshrc，可以通过编辑这个文件来指定主题，插件。 重新安装 如果在使用过程中， MSYS2 出现不可恢复的问题的时候，可以通过保存安装的 packages 到文件中，再通过此文件重新安装。 保存现有安装包列表到 C 盘中的 packages.txt pacman -Qqe | xargs echo &gt; /c/packages.txt ; exit 根据保存的 packages.txt 安装 123pacman -Sypacman --needed -S bash pacman pacman-mirrors msys2-runtimepacman -S --needed --force $(cat /c/packages.txt) 坑 如果你使用 MacType 的话，请一定在 default.ini (MacType的配置文件) 添加 gpg/pacman 的例外。 123[UnloadDll]gpg.exepacman.exe via #393 GPGME error: Invalid crypto engine 如果你使用 VirtualBox 4.3.14+ 的话，也需要把相关进程排除。via VirtualBox 4.3.12以后的E_FAIL (0x80004005)问题 ---EOF---]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>msys2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修正 SourceTree 无法识别 msys2 中 Git]]></title>
    <url>%2Ffix-sourcetree-can-not-find-msys2-git%2F</url>
    <content type="text"><![CDATA[问题 SourceTree 真是一个让人又爱又恨的产品，小问题不断，但是在免费的 Git 的 GUI 里面还算优秀的。因为 TortoiseGit 对 msys2 支持不好，我又回到 SourceTree 阵营了, SourceTree 为主， CLI 辅助。 因为 SourceTree 不能识别 msys2 的 Git，虽然其自带一个内嵌的 Git，这样就导致了我需要配置两份全局的 gitconfig。 解决方案 其实原因很简单，因为 SourceTree 要求 Git 所在目录必须同时有 bin 和 cmd 文件夹。听起来很2是吧？知道了原因要解决起来就很简单。 我的 msys2 安装在 d:\msys64，在 SourceTree 中选择 系统安装的Git (工具/选项/Git) 在 AppData 中的 user.config 配置中 GitSystemPath 节点会自动识别出 msys2 的路径 123&lt;setting name="GitSystemPath" serializeAs="String"&gt; &lt;value&gt;D:\msys64\usr&lt;/value&gt;&lt;/setting&gt; 通过 mklink 建立一个链接 在 D:\msys64\usr 建立链接 mklink /D cmd bin ---EOF---]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>SourceTree</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eDNA C API 介绍]]></title>
    <url>%2Fedna-api-demo-by-c%2F</url>
    <content type="text"><![CDATA[介绍 eDNA是一个领导性的实时/历史数据系统。eDNA采集、存储和展示大量的工程和运行信息。eDNA将深入在整个企业范围内的数据采集上来，以极高的无损压缩方式存储起来，使得以时间序列频繁变化的数据能以原有的数据精度和时间精度在线保存多达几十年。eDNA使基于运行状况的及时和准确的决策成为可能，极大地降低运行成本。eDNA具有完全分布的体系结构，让正确的人在正确的时间做出正确的决定。eDNA是一套实时的运行管理解决方案，它提供了对你的生产运行中无限制的观察和分析，使得你能够根据丰富的信息迅速地做出决策，你的一线生产能力将会大大提高。via 印步 API eDNA 分为两种： 常规API：支持 C/C++/Visual Basic 等。这种方式需要自己组装报文，虽然有相关 API 函数支持，但是实际应用起来还是比较麻烦 EzDNA：封装了常用的操作，只需要引入一个头文件 (EzDnaApi.h) 即可。 注：两种方式都需要安装 eDNA 的 Client 程序。 示例代码 涉及到的 API 函数： DNAGoodPointFormat 检查测点名称是否符合命名规范 DoesIdExist 检查测点是否存在 DNAGetRTFull 查询指定测点的实时数据 DNAGetHSFull 同上 注： DNAGetHSFull 查询到的时间精度是毫秒，如果对时间有要求，建议使用此函数。但是在实际使用过程中，发现此函数有时候会查询不到数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960int16_t getsnapshot()&#123; edna_tag_t *tag; int32_t index; int32_t *buff_size; int16_t counter; int32_t ret; int8_t log_tag[MAX_BUFF_SIZE]; int8_t szValue[EDNA_LEN]; int32_t ptTime; int8_t szmS[EDNA_LEN]; uint16_t pusStatus; int8_t szStatus[EDNA_LEN]; int8_t szDesc[EDNA_DESC_LEN]; int8_t szUnits[EDNA_LEN]; strncpy(log_tag, "getsnapshot", MAX_BUFF_SIZE); // init parameters // .... for (index = 0; index &lt; ptbl_data-&gt;point_size; index++, tag++) &#123; // other stuff // ... if (tag-&gt;flag == E_EMPTY_TAG) continue; // tests the string, validating it as a fully qualified eDNA point name if (DNAGoodPointFormat(tag-&gt;name) == 0) &#123; tag-&gt;flag = INVALID; continue; &#125; // check point name is exist if (!DoesIdExist(tag-&gt;name)) &#123; tag-&gt;flag = NOT_EXIST; continue; &#125; // retrieves the value, time and status in their raw formats ret = DNAGetRTFull(tag-&gt;name, &amp;tag-&gt;value, szValue, EDNA_LEN, &amp;ptTime, tag-&gt;ts, EDNA_LEN, &amp;pusStatus, szStatus, EDNA_LEN, szDesc, EDNA_DESC_LEN, szUnits, EDNA_LEN);#if 0 ret = DNAGetHSFull(tag-&gt;name, &amp;tag-&gt;value, szValue, EDNA_LEN, &amp;ptTime, tag-&gt;ts, EDNA_LEN, &amp;tag-&gt;ms, szmS, EDNA_LEN, &amp;pusStatus, szStatus, EDNA_LEN, szDesc, EDNA_DESC_LEN, szUnits, EDNA_LEN);#endif tag-&gt;flag = (ret == 0) ? NORMAL : OFFLINE; &#125; return TRUE;&#125; ---EOF---]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>rtdb</tag>
        <tag>eDNA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OSI PI C API 介绍]]></title>
    <url>%2Fosi-pi-api-demo-by-c%2F</url>
    <content type="text"><![CDATA[介绍 PI（Plant Information System）是由美国 OSIsoft 公司开发的一套基于 Client/Server 结构的商品化软件应用平台，是过程工业全厂信息集成的必然选择。作为工厂底层控制网络与上层管理信息系统网络连接的桥梁，PI 在工厂信息集成中扮演着特殊和重要的角色。更详细的介绍，可参考百度百科或者官方网站 登录数据库 要访问数据库，有两种方法，一种是通过用户名和密码登录，另一种是通过 PI Trust。官方是不建议使用密码登录的，所以在开发应用的时候，尽可能使用 PI Trust，但是国内的情况比较混乱，很多生产环境都还是使用第一次方式。 下面分别介绍两种登录方法的使用 用户名/密码登录 这种方式比较简单，Server 端几乎不需要任何配置，只要简单添加一个用户即可。 涉及到的 API 函数： piut_setservernode 设置 PI Server 节点，一般就是 Server 的 IP 地址 piut_isconnected 是否已经和 Server 连接 piut_login 传入用户名/密码，根据返回值判断是否连接成功，如果需要写数据的话，需要注意写权限 在 PI 3.x 中，默认是不启用用户名/密码登录的，需要注意 PI Trust 登录 这种方式，是官方推荐做法，需要在 Server 段添加相应的 PI Trust 设置，可以设置 IP 地址/Client 名称/进程名字等，配置非常灵活。 涉及到的 API 函数： piut_setservernode 同上 piut_isconnected 同上 piut_setprocname 设置 Client 的进程名，需要和 Server 段设置一致 piut_connect 连接 Server 示例代码，功能就是根据配置参数自动判断连接方式，因为我们生产环境是个很老的现场，所以优先使用用户名/密码登录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566error_t connect_pi(server_info_t *server)&#123; int32_t result; int32_t valid; int8_t version[SERVER_FIELD_SIZE]; int8_t log_tag[MAX_BUFF_SIZE]; int8_t pro_name[SERVER_FIELD_SIZE]; valid = PIREAD; strncpy(log_tag, "connect pi", MAX_BUFF_SIZE); if (piut_isconnected() == 0) &#123; // retrieves the version number of the PI-API. if (piut_getapiversion(version, sizeof(version)) == 0) &#123; ftrace_log(log_tag, "PI-API version %s", version); &#125; if (server-&gt;misc3 == NULL || strlen(server-&gt;misc3) == 0) &#123; strncpy(pro_name, "pi_snap", SERVER_FIELD_SIZE); &#125; else &#123; strncpy(pro_name, server-&gt;misc3, SERVER_FIELD_SIZE); &#125; // sets the active PI Server node where the data for the subsequent // PI-API calls will be resolved result = piut_setservernode(server-&gt;server_ip); if (result) &#123; ftrace_log(log_tag, "piut_setservernode: can not connect to %s", server-&gt;server_ip); return E_CONNECT_FAILED; &#125; if (server-&gt;usr_name != NULL &amp;&amp; strlen(server-&gt;usr_name) &gt; 0) &#123; // establishes a user's access to PI System data based on a login to a configured user database result = piut_login(server-&gt;usr_name, server-&gt;usr_pwd, &amp;valid); if (result == 0) &#123; ftrace_log(log_tag, "piut_login: connect to %s successful, valid=%d", server-&gt;server_ip, valid); return E_SUCCESS; &#125; ferror_log(log_tag, "piut_login: connect to %s failed, ret=%d", server-&gt;server_ip, result); &#125; //sets the global process name to the passed string piut_setprocname(pro_name); result = piut_connect(server-&gt;server_ip); if (result) &#123; ferror_log(log_tag, "piut_connect: connect to %s failed, ret=%d", server-&gt;server_ip, result); return E_CONNECT_FAILED; &#125; &#125; return E_SUCCESS;&#125; 初始化测点信息 连接上 Server 之后，需要根据测点信息，转换成数据库中对应的id，方便后面的操作 涉及到的 API 函数： pipt_findpoint 转换测点名称为测点号 (必须) pipt_pointtypex 根据测点号查询对应的测点类型 pipt_displaydigits 根据测点号查询显示位数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static int16_t init_pi_tag(pi_tag_t *tag)&#123; int32_t result; int8_t log_tag[MAX_BUFF_SIZE]; strncpy(log_tag, "init_pi_tag", MAX_BUFF_SIZE); // gets the point number for the given tagname result = pipt_findpoint(tag-&gt;name, &amp;tag-&gt;point_id); if (result) &#123; ftrace_log(log_tag, "fetch point[%s] id failed.", tag-&gt;name); tag-&gt;stat = NOT_EXIST; return FALSE; &#125; // gets the data type code for the passed point number result = pipt_pointtypex(tag-&gt;point_id, &amp;tag-&gt;pt_typex); if (result) &#123; ftrace_log(log_tag, "fetch point[%s] typex failed.", tag-&gt;name); tag-&gt;stat = INVALID; return FALSE; &#125; // gets the display digits attribute for the passed point number result = pipt_displaydigits(tag-&gt;point_id, &amp;tag-&gt;display_prec); if (result) &#123; ftrace_log(log_tag, "fetch point[%s] display digits failed.", tag-&gt;name); tag-&gt;display_prec = -5; &#125; tag-&gt;stat = NORMAL; tag-&gt;rval = (float64_t) 0.0; tag-&gt;istat = 0; tag-&gt;ival = 0; tag-&gt;flag = 0; ftrace_log(log_tag, "name:%s, id:%d, dis_prec: %d,type: %d", tag-&gt;name, tag-&gt;point_id, tag-&gt;display_prec, (int32_t)tag-&gt;pt_typex); switch (tag-&gt;pt_typex) &#123; case PI_Type_PIstring: case PI_Type_blob: case PI_Type_PItimestamp: if (tag-&gt;bsize == 0) &#123; /* Skip allocation if a subsequent run. */ if ((tag-&gt;bval = (void *)malloc(BVALUE_BUFF)) == NULL) &#123; error_log(log_tag, "malloc bval failed."); destory(); return E_MALLOC_FAILED; &#125; &#125; tag-&gt;bsize = (tag-&gt;bsize &gt; BVALUE_BUFF - 1) ? tag-&gt;bsize : BVALUE_BUFF - 1; memset(tag-&gt;bval, 0, (size_t)(tag-&gt;bsize + 1)); break; case PI_Type_int16: case PI_Type_int32: tag-&gt;bsize = 0; break; case PI_Type_digital: tag-&gt;bsize = 0; break; default:/* floats, PI2 */ tag-&gt;bsize = 0; break; &#125; /* End switch */ return TRUE;&#125; 查询实时数据 从快照中查询数据库，可以通过 pisn_getsnapshot 或者 pisn_getsnapshotx 查询，具体可查考 API 文档。 注： pisn_getsnapshot 获取的时间只到秒级，如果对时间精度要求比较高，需要使用 pisn_getsnapshotx。 1234567891011121314151617181920212223242526272829303132int16_t getsnapshot()&#123; // init parameters etc. // ... for (index = 0; index &lt; ptbl_data-&gt;point_size; index++, tag++) &#123; // check server connection etc // ... tag-&gt;rval = 0; tag-&gt;istat = 0; result = pisn_getsnapshot(tag-&gt;point_id, &amp;tag-&gt;rval, &amp;tag-&gt;istat, &amp;tag-&gt;time); if (result == 0) &#123; ftrace_log(log_tag, "%s[0x%p] pisn_getsnapshot, rval=%f,ival=%d,time=%d", tag-&gt;name, tag, tag-&gt;rval, tag-&gt;istat, tag-&gt;time); &#125; else if (result == -1) &#123; tag-&gt;stat = NOT_EXIST; ftrace_log(log_tag, "%s pisn_getsnapshot not exist, result=%d.", tag-&gt;name, result); &#125; else &#123; tag-&gt;stat = INVALID; ftrace_log(log_tag, "%s pisn_getsnapshot failed, result=%d.", tag-&gt;name, result); &#125; &#125; return TRUE;&#125; ---EOF---]]></content>
      <categories>
        <category>Programming</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>PI</tag>
        <tag>rtdb</tag>
      </tags>
  </entry>
</search>
